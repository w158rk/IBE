<  This file is the implementation of BasicIdent scheme of the IBE system.(Chapter 4.1)
---
>  This file is the implementation of BasicIdent scheme of the IBE system.(Chapter 4.2)
20,21c20,23
<  3.As I use SHA1 function as H2 function, thus the n is automatically set as 160.
<  4.In my code, I use type A parameter to generate pairing.
---
>  3.H3 function---Concatenate the sigma and message digest, and
>  then put it into build-in function element_random. The random number will between 0 and q.
>  4.H4 function---Input a 160 bit long number and run SHA1 function to generate another 160 bit long number.
>  5.As I use SHA1 function as H2 function, thus the n is automatically set as 160.

> void rand_n(char* sigma)
> {
>   int i;
>   int unit;
>   char tempr[10];
>   memset(sigma, 0, sizeof(char)*SIZE);//Clear the memory of sigma
>   
>   for (i = 0; i < 40; i++)
>   {
>   unit = rand() % 16;
>   sprintf(tempr, "%X", unit);
>   strcat(sigma, tempr);
>   
>   }
>   
61,62c79
< void encryption(char* shamessage, char* ID, element_t P, element_t P_pub,
<                 element_t U, char* V, pairing_t pairing)
---
> void encryption(char* shamessage,char* ID, element_t P,element_t Ppub,element_t U,char* V,char* W, pairing_t pairing)
67c84,86
<     
---
>   char sigma[SIZE]; //Sender generate the sigma
>   char msigma[2*SIZE]; //Sender concatenate the sigma and message digest
>   char ssigma[SIZE]; //It is the result of H4(sigma)
74c93,96
<   element_random(r);
---
>   rand_n(sigma); //Sender generate a sigma
>   strcpy(msigma, sigma);
>   strcat(msigma, shamessage);
>   element_from_hash(r, msigma, strlen(msigma));
76,78c98,99
<   element_printf("U = %B", U);
<   get_public_key(ID, pairing, Qid);
<   element_pairing(gid, Qid, P_pub);
---
>   element_printf("\nU = %B", U);
>   element_pairing(gid, Qid, Ppub);
81,85c102,108
<   sha_fun(sgid, shagid);
<     
<   //Do the XOR operation to the shamessage and shagid
<   for (i = 0; i < 40; i++) {
<     xor_operation(shamessage[i], shagid[i], V);
---
>   sha_fun(sgid, shagid); //H2(gid^r)
>   sha_fun(sigma, ssigma); //H4(SIGMA)
>   
>   //Do the XOR operation to the sigma and shagid digest
>   for (i = 0; i < 40; i++)
>   {
>   xor_operation(sigma[i], shagid[i], V);
87,89c110,117
<     
<   printf("\nV=%s\n", V);
<     
---
>   //Do the XOR operation to the ssigma and message digest
>   for (i = 0; i < 40; i++)
>   {
>   xor_operation(shamessage[i], ssigma[i], W);
>   }
>   
>   printf("\nV=%s", V);
>   printf("\nW=%s\n", W);
92,93c120
< void decryption(element_t Sid, pairing_t pairing, element_t U, char* V,
<                 char* xor_result_receiver)
---
> void decryption(element_t Sid,pairing_t pairing,element_t P,element_t U,char* V,char* W,element_t U_receiver,char* shamessage_receiver)
95c122
<     
---
>   
97a125
>   element_t r_receiver;
99a128,134
>   char sigma_receiver[SIZE]; //Receiver compute the sigma
>   char ssigma_receiver[SIZE]; //It is the result of H4(sigma_receiver)
>   char msigma_receiver[2*SIZE]; //Receiver concatenate the sigma and message digest
>   memset(sigma_receiver, 0, sizeof(char)*SIZE);//Clear the memory of sigma_receiver
>   memset(shamessage_receiver, 0, sizeof(char)*SIZE);//Clear the memory of shamessage_receiver
>   
>   element_init_Zr(r_receiver,pairing);
103,107c138,151
<   sha_fun(sgid_receiver, shagid_receiver);  //Generate H2(e(dID,U));
<     
<   //XOR V and the hash result above
<   for (i = 0; i < 40; i++) {
<     xor_operation(V[i], shagid_receiver[i], xor_result_receiver);
---
>   sha_fun(sgid_receiver, shagid_receiver); //Generate H2(e(dID,U));
>   
>   //XOR V and H2(e(dID,U))=sigma_receiver
>   for (i = 0; i < 40; i++)
>   {
>   xor_operation(V[i], shagid_receiver[i], sigma_receiver);
>   }
>   
>   sha_fun(sigma_receiver, ssigma_receiver);
>   
>   //XOR W andH4(sigma)
>   for (i = 0; i < 40; i++)
>   {
>   xor_operation(W[i], ssigma_receiver[i], shamessage_receiver);
109c153,160
<     
---
>   
>   strcpy(msigma_receiver, sigma_receiver);
>   strcat(msigma_receiver, shamessage_receiver);
>   element_from_hash(r_receiver, msigma_receiver, strlen(msigma_receiver));
>   element_mul_zn(U_receiver, P, r_receiver);
>   
>   
>   
114c165
<     
---
>   
118,119c169,170
<     
<     
---
>   
>   
122,123c173,174
<     pbc_die("pairing must be symmetric");
<     
---
>   pbc_die("pairing must be symmetric");
>   
130c181
<     
---
>   
133c184,186
< int main()
---
> 
> 
> int main(int argc, char **argv)
135c188
<     
---
>   int i;
138,139c191,192
<   char ID[SIZE];   //User ID
<   char message[SIZE];   //User message
---
>   char ID[SIZE];
>   char message[SIZE];//User message
141,147c194,200
<     
<   char xor_result[SIZE]; //Sender XOR result---V
<   char xor_result_receiver[SIZE];  //Receiver XOR result
<   memset(xor_result, 0, sizeof(char)*SIZE);
<   memset(xor_result_receiver, 0, sizeof(char)*SIZE);
<     
<     
---
>   
>   char V[SIZE];
>   char W[SIZE];
>   memset(V, 0, sizeof(char)*SIZE);//Clear the memory of V
>   memset(W, 0, sizeof(char)*SIZE);//Clear the memory of W
>   char shamessage_receiver[SIZE]; //Receiver compute the message
>   
149,150c202,203
<     
<   element_t P, Ppub, s, U, Qid, Sid;
---
>   
>   element_t P, Ppub, s, U, U_receiver, Qid, Sid;
153c206,208
<     
---
>   
>   
>   
155c210
<     printf("Please enter rbits:");
---
>   printf("Please enter rbits:");
157c212
<     getchar();
---
>   getchar();
160,161c215,216
<     getchar();
<     
---
>   getchar();
>   
166,169c221,223
<     
<     
<     printf("###########EXTRACT###########\n");
<     element_init_G1(Qid, pairing);
---
>   
>   printf("###########EXTRACT###########\n");
>   element_init_G1(Qid, pairing);
172,176c226,232
<   scanf("%[ a-zA-Z0-9+*-!.,&*@{}$#]", ID);
<   printf("\nID=%s\n", ID);
<     getchar();
<     get_private_key(ID, pairing, s, Sid);
<   get_public_key(ID, pairing, Qid);
---
>   scanf("%[ a-zA-Z0-9+*-!.,&*@{}$#]",ID);
>   printf("\nID=%s\n",ID);
>   getchar();
>   get_private_key(ID,pairing,s,Sid);
>   get_public_key(ID,pairing,Qid);
>   
>   
178,179c234,235
<     printf("\nPlase enter the message to encrypt:");
<   scanf("%[ a-zA-Z0-9+*-!.,&*@{}$#]", message);
---
>   printf("Plase enter the message to encrypt:");
>   scanf("%[ a-zA-Z0-9+*-!.,&*@{}$#]",message);
181,201c237,254
<   printf("The original message=%s", message);
<     
<     sha_fun(message, shamessage);   //Get the message digest
<   printf("\nThe message hash=%s\n", shamessage);
<     
<     element_init_G1(U, pairing);
<   encryption(shamessage, ID, P, Ppub, U, xor_result, pairing);
<   printf("Send <U,V> to the receiver!\n");
<     
<   printf("##########DECRYPTION##########");
<   decryption(Sid, pairing, U, xor_result, xor_result_receiver);
<   printf("\nThe recovery message digest is %s\n", xor_result_receiver);
<   printf("The original message digest is %s\n", shamessage);
<     
<   if (strcmp(xor_result_receiver, shamessage) == 0) {
<         
<     printf("Yeah!The message has been decrpted!\n");
<   }
<     
<   else {
<     printf("Oops!The message can not be decrpted!\n");
---
>   printf("\nThe original message=%s",message);
>   //Get the hash of the message
>   sha_fun(message, shamessage);
>   
>   element_init_G1(U, pairing);
>   encryption(shamessage,ID,P,Ppub,U,V,W,pairing);
>   
>   printf("Send (U,V,W) to the receiver!");
>   
>   printf("\n##########DECRYPTION##########");
>   element_init_G1(U_receiver, pairing);
>   decryption(Sid,pairing,P,U,V,W,U_receiver,shamessage_receiver);
>   if (element_cmp(U, U_receiver) == 0)
>   {
>   element_printf("\nU=%B", U);
>   element_printf("\nU_receiver=%B", U_receiver);
>   printf("\nYeah!The message is decrpted!");
>   printf("\nThe Message Disgest=%s\n", shamessage_receiver);
203,204c256,263
<     
<   //Free space
---
>   
>   else
>   {
>   element_printf("\nU=%B", U);
>   element_printf("\nU_receiver=%B", U_receiver);
>   printf("\nOops!The ciphertext can not be accepted!\n");
>   }
>   
212c271
<     
---
>   
214a274,275
> 
> 
